import { v } from "convex/values";
import {
  action,
  internalMutation,
  mutation,
  query,
  internalAction, // Added internalAction import if processImage uses it
} from "./_generated/server";
import { Id } from "./_generated/dataModel";
import OpenAI from "openai";
import { internal } from "./_generated/api"; // Import internal API
import { paginationOptsValidator } from "convex/server"; // Import pagination validator

// System prompts for different styles
export const SYSTEM_PROMPTS = {
  "Studio Laika": "A stop-motion-inspired image in the style of Studio Laika (Coraline, Kubo).",
  "3dsoft": "A Pixar-style 3D animated image.",
  Ghibli: "A Studio Ghibli-style watercolor image.",
  "80s Anime": "A 1980s anime style image.",
  "T206 Vintage": "A vintage T206 image style.",
  futuristic:
    "A futuristic image with a dark, moody neon aesthetic and soft sci-fi lighting, holographic materials, glowing edges, and subtle motion-blur reflections.",
  "b&w":
    "A high-contrast black and white image with dramatic shadows and a timeless, cinematic style.",
  convex:
    "A modern, clean image with rounded shapes, soft shadows, and playful gradients in Convex brand colors. The style should feel developer-first and real-time reactive, with a subtle grid or node pattern in the background. Typography should be bold and geometric, evoking a high-performance backend platform.",
};

// Process image using OpenAI
export const processImage = action({
  args: {
    prompt: v.string(),
    style: v.string(),
  },
  returns: v.object({
    storageId: v.id("_storage"),
    galleryId: v.id("gallery"),
    imageUrl: v.string(),
    aiResponse: v.string(),
  }),
  handler: async (ctx, args) => {
    try {
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });

      const systemPrompt = SYSTEM_PROMPTS[args.style as keyof typeof SYSTEM_PROMPTS];
      const response = await openai.images.generate({
        model: "dall-e-3",
        prompt: `${systemPrompt} The image should include: ${args.prompt}`,
        n: 1,
        size: "1024x1024",
        quality: "standard",
        response_format: "url",
      });

      const imageUrlFromOpenAI = response.data[0]?.url;
      if (!imageUrlFromOpenAI) {
        throw new Error("No image generated by OpenAI");
      }

      // Upload the generated image to Convex storage
      const imageResponse = await fetch(imageUrlFromOpenAI);
      const imageBlob = await imageResponse.blob();
      const storageId = await ctx.storage.store(imageBlob);

      // Get the URL for the stored image
      const imageUrl = await ctx.storage.getUrl(storageId);
      if (!imageUrl) {
        throw new Error("Could not get image URL from storage");
      }

      // Save the image details to the gallery table via an internal mutation
      const galleryId: Id<"gallery"> = await ctx.runMutation(
        internal.gallery.internalSaveProcessedImage,
        {
          storageId,
          style: args.style,
          prompt: args.prompt,
          aiResponse: "Image generated successfully!", // Or use revised_prompt if available
        }
      );

      return {
        storageId,
        galleryId,
        imageUrl,
        aiResponse: "Image generated successfully!",
      };
    } catch (error) {
      console.error("Error processing image:", error);
      // Propagate a more specific error or handle it as needed
      if (error instanceof Error) {
        throw new Error(`Failed to process image: ${error.message}`);
      } else {
        throw new Error("Failed to process image due to an unknown error");
      }
    }
  },
});

// Internal mutation to save processed image details to the gallery
export const internalSaveProcessedImage = internalMutation({
  args: {
    storageId: v.id("_storage"),
    style: v.string(),
    prompt: v.string(),
    aiResponse: v.optional(v.string()),
  },
  returns: v.id("gallery"),
  handler: async (ctx, args): Promise<Id<"gallery">> => {
    return await ctx.db.insert("gallery", {
      storageId: args.storageId,
      style: args.style,
      prompt: args.prompt,
      aiResponse: args.aiResponse ?? "",
      likes: 0,
      commentCount: 0,
      clicks: 0, // Initialize clicks to 0
    });
  },
});

// List gallery images with pagination
export const listGallery = query({
  args: { paginationOpts: paginationOptsValidator }, // Revert: Keep paginationOpts required
  handler: async (ctx, args) => {
    // Return paginated results
    const images = await ctx.db.query("gallery").order("desc").paginate(args.paginationOpts); // Use paginate()
    return images;
    // No need to fetch URLs here anymore
  },
});

// Get gallery count
export const getGalleryCount = query({
  args: {},
  handler: async (ctx) => {
    const count = await ctx.db.query("gallery").collect();
    return count.length;
  },
});

// Get image from storage
export const getImage = query({
  args: { imageId: v.id("_storage") },
  handler: async (ctx, args) => {
    const imageUrl = await ctx.storage.getUrl(args.imageId);
    return { imageUrl };
  },
});

// Get comments for an image
export const getComments = query({
  args: { galleryId: v.id("gallery") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("comments")
      .withIndex("by_gallery", (q) => q.eq("galleryId", args.galleryId))
      .collect();
  },
});

// Add a comment
export const addComment = mutation({
  args: {
    galleryId: v.id("gallery"),
    userName: v.string(),
    text: v.string(),
  },
  handler: async (ctx, args) => {
    // Fetch the gallery item to increment comment count
    const galleryItem = await ctx.db.get(args.galleryId);
    if (!galleryItem) {
      throw new Error("Gallery item not found to add comment");
    }
    // Increment comment count
    await ctx.db.patch(args.galleryId, {
      commentCount: (galleryItem.commentCount || 0) + 1,
    });
    // Insert the comment
    return await ctx.db.insert("comments", {
      galleryId: args.galleryId,
      userName: args.userName,
      text: args.text,
    });
  },
});

// Add a like
export const addLike = mutation({
  args: { galleryId: v.id("gallery") },
  handler: async (ctx, args) => {
    const gallery = await ctx.db.get(args.galleryId);
    if (!gallery) throw new Error("Gallery not found");

    return await ctx.db.patch(args.galleryId, {
      likes: (gallery.likes || 0) + 1,
    });
  },
});

/**
 * Increment the click count for a specific image.
 */
export const incrementImageClicks = mutation({
  args: {
    imageId: v.id("gallery"),
  },
  handler: async (ctx, args) => {
    const image = await ctx.db.get(args.imageId);
    if (!image) {
      console.error(`Image not found: ${args.imageId}`);
      // Consider throwing an error for better client feedback
      // throw new Error(`Image not found: ${args.imageId}`);
      return; // Return early if image doesn't exist
    }
    // Use patch to update the clicks field, ensuring atomicity
    // Initialize clicks to 0 if it's null/undefined before incrementing
    await ctx.db.patch(args.imageId, { clicks: (image.clicks ?? 0) + 1 });
  },
});

// --- Dashboard Queries ---

// Get last 20 prompts
export const getLast20Prompts = query({
  args: {},
  handler: async (ctx) => {
    const prompts = await ctx.db
      .query("gallery")
      .order("desc") // Order by _creationTime descending (default index)
      .take(20);
    // Map to include clicks
    return prompts.map((p) => ({
      ...p, // Spread existing fields
      clicks: p.clicks ?? 0, // Ensure clicks is returned, default to 0 if null/undefined
    }));
  },
});

// Get last 20 styles used
export const getLast20Styles = query({
  args: {},
  handler: async (ctx) => {
    const styles = await ctx.db
      .query("gallery")
      .order("desc") // Order by _creationTime descending
      .take(20);
    // Map to include clicks
    return styles.map((s) => ({
      ...s,
      clicks: s.clicks ?? 0,
    }));
  },
});

// Get all prompts (Limited to 100 for performance, consider pagination later)
export const getAllPrompts = query({
  args: {},
  handler: async (ctx) => {
    const prompts = await ctx.db
      .query("gallery")
      .order("desc") // Order by _creationTime descending
      .take(100); // Limit for performance
    // Map to include clicks
    return prompts.map((p) => ({
      ...p,
      clicks: p.clicks ?? 0,
    }));
  },
});

// Get 20 most liked images
export const getMostLikedImages = query({
  args: {},
  handler: async (ctx) => {
    const images = await ctx.db
      .query("gallery")
      .withIndex("by_likes", (q) => q) // Use the likes index
      .order("desc") // Order by likes descending
      .take(20);
    // Map to include clicks
    return images.map((img) => ({
      ...img,
      clicks: img.clicks ?? 0,
    }));
  },
});

// Get 20 most commented images
export const getMostCommentedImages = query({
  args: {},
  handler: async (ctx) => {
    const images = await ctx.db
      .query("gallery")
      // Make sure index name matches schema: by_comment_count
      .withIndex("by_comment_count", (q) => q)
      .order("desc") // Order by commentCount descending
      .take(20);
    // Map to include clicks
    return images.map((img) => ({
      ...img,
      clicks: img.clicks ?? 0,
    }));
  },
});
